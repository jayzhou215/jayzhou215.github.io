---
layout: post
title: Algorithm - insert sort
tags: [go]
readtime: true
comments: true
---

### insert sort
1. 插入排序的定义 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
2. 基本步骤
    1. 从第一个元素开始，该元素可以认为已经被排序
    2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
    3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
    4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
    5. 将新元素插入到该位置后
    6. 重复步骤2~5
2. 示例代码分析
    1. 循环n-1次，此循环次数不可减少
    2. 记录单次循环中最小值位置，交互未排序数组中首元素值与最小值
3. [select sort code](../algorithm/sort/select.go)
4. 时间空间复杂度
    1. 时间复杂度: 外循环和内循环以及判断和交换元素的时间开销
        * 比较操作，总是 n*(n-1)/2，即O(n^2)
        * 交换操作，最优0次，最坏n-1次，即O(n)
        * 赋值操作，0 ~ 3*(n-1)
    2. 空间复杂度: 交换元素时那个临时变量所占的内存空间
        * 交互在golang中是隐式的，空间为2，即O(1)
        * 赋值操作空间为1，即O(1)
    3. 稳定性 stability
        * 因为判断条件是left > right，等值时不会发生交换，总是稳定的    

### 优点
简单 & in-place(原地操作，无需过多辅助空间)

### 缺点
1、和冒泡排序同样的问题，存在大量比较只在当次循环有效
2、无及时跳出循环的方式

### 引申知识点
1. 交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
2. 当n值较大时，选择排序在下面的测试中慢于冒泡排序，原因是冒泡排序通过判断是否有发生交换来跳出循环，但选择排序无法做出类似的优化

### bench测试
